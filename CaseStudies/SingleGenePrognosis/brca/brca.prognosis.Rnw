%\VignetteEngine{knitr::knitr}

<<setup, include=FALSE, cache=FALSE>>=
# Set options
knitr::opts_chunk$set(include=TRUE, results="hide", fig.width=8, fig.height=8, fig.path='figures/', fig.align='center', fig.show='hold',warning=FALSE, echo=FALSE, message=FALSE, cache=FALSE)
options(replace.assign=TRUE,width=90)
days.per.month <- 30.4368
days.per.year <- 365.242
par.original <- par()
library(knitr)
library(MetaGx)
library(gdata)
library(annotate)
library(ggplot2)
library(xtable)
library(genefu)
library(reshape2)
library(hgu133plus2.db)
library(metafor)
library(devtools)
@


\documentclass{article}

\usepackage{graphicx}
\usepackage{microtype}
\usepackage[T1]{fontenc}
\usepackage{float}
\usepackage[latin1]{inputenc}
\usepackage{geometry}
\usepackage{titlesec}
\usepackage{tabularx}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\usepackage[table]{xcolor}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
%\newcommand{\sectionbreak}{\clearpage}

\begin{document}

\title{Breast Cancer Prognosis}

%\author{Gregory M. Chen}
\date{\today}
\maketitle




<<load_data, cache=TRUE>>=
source(system.file("extdata", "patientselection.config", package="MetaGxBreast"))
source(system.file("extdata", "createEsetList.R", package="MetaGxBreast"))

esets <- lapply(esets, function(x) {
  factor.indices <- sapply(pData(x), is.factor)
  pData(x)[factor.indices] <- lapply(pData(x)[factor.indices], as.character)
  return(x)
  })
esets <- lapply(esets, function(x) {
  x <- subtypeClassification(x, model = "scmod2")
  return(x)
  })
eset.names <- names(esets)
esets <- lapply(names(esets), function(x) {
  eset.toreturn <- esets[[x]]
  eset.toreturn$data.source <- x
  return(eset.toreturn)
  })
names(esets) <- eset.names

gene.table <- read.table("brca.genes.tsv", sep="\t", header=TRUE, stringsAsFactors = FALSE)
gene.names <- gene.table$Gene.name
entrez.ids <- gene.table$Entrez.ID
names(entrez.ids) <- gene.names

# For each dataset: if it contains some patients with the genes, remove patients with NA values for these genes
#esets <- lapply(esets, function(eset) {
#  for(entrez.id in entrez.ids) {
#    if(entrez.id %in% fData(eset)$EntrezGene.ID) {
#      index <- which(fData(eset)$EntrezGene.ID == entrez.id)
#      eset <- eset[, !is.na(exprs(eset)[index,,drop=FALSE]) ]
#      }
#  }
#  return(eset)
#})

# For each dataset, remove genes that are not represented in all patients
#esets <- lapply(esets, function(eset) eset[complete.cases(exprs(eset)),])

# only keep patients with survival data
esets.os <- lapply(esets, function(eset) eset[,!is.na(eset$days_to_death) & !is.na(eset$vital_status)])
esets.rfs <- lapply(esets, function(eset) eset[,!is.na(eset$recurrence_status) & !is.na(eset$days_to_tumor_recurrence)  |  !is.na(eset$dmfs_status) & !is.na(eset$dmfs_days)])

## Remove datasets that are empty
esets.os <- esets.os[sapply(esets.os, function(x) ncol(exprs(x)) > 0)]
esets.rfs <- esets.rfs[sapply(esets.rfs, function(x) ncol(exprs(x)) > 0)]

esets.with.all.genes <- esets[
    sapply(esets, function(eset) {
      return(all(entrez.ids %in% as.character(fData(eset)$EntrezGene.ID)))
      })
  ]


#esets.merged <- MetaGx::datasetMerging(esets.with.all.genes)

@

\tableofcontents
\pagebreak
\section{Datasets}

\subsection{All Datasets}

<<get_num_genes_datasets>>=
num.patients <- sum(sapply(esets, function(x) ncol(exprs(x))))
num.datasets <- length(esets)

num.patients.survival <- sum(sapply(esets.rfs, function(x) ncol(exprs(x))))
num.datasets.survival <- length(esets.rfs)
@

For gene coexpression and GSEA, we used \Sexpr{num.patients} patients from \Sexpr{num.datasets} datasets:
<<Dataset_table, results='asis'>>=
data.counts <- as.data.frame(sapply(esets, function(x) ncol(exprs(x))))
colnames(data.counts) <- "Number of samples"
data.counts <- rbind(data.counts, sum(data.counts[,1]))
rownames(data.counts)[nrow(data.counts)] <- "Sum"
xtable(data.counts)
@

\pagebreak

\subsection{Datasets for Survival Analysis}

For survival analysis, we selected patients from studies which tracked recurence-free survival. When recurrence-free survival was unavailable, we used distant metastatis-free survival.  We identified \Sexpr{num.patients} patients from \Sexpr{num.datasets} datasets.
<<Dataset_table_survival, results='asis'>>=
data.counts <- as.data.frame(sapply(esets.rfs, function(x) ncol(exprs(x))))
colnames(data.counts) <- "Number of samples"
data.counts <- rbind(data.counts, sum(data.counts[,1]))
rownames(data.counts)[nrow(data.counts)] <- "Sum"
xtable(data.counts)
@

\section{Pairwise Coexpression}

<<Pairwise_coexpression, fig.width=6, fig.height=6, out.width="0.6\\textwidth">>=
# Get pairwise coexpression matrix
get.meta.correlation <- function(pcc, n) {
  fisher.z <- 0.5 * log( (1 + pcc) / (1 - pcc) )
  fisher.z.var <- 1 / (n - 3)
  fisher.z.sd <- sqrt(fisher.z.var)
  fisher.z.meta <- survcomp::combine.est(fisher.z, fisher.z.sd, hetero=TRUE, na.rm=TRUE)$estimate
  pcc.meta <- (exp(2*fisher.z.meta) - 1) / (exp(2*fisher.z.meta) + 1)
  return(pcc.meta)
}

get.meta.correlation.hunter.schmidt <- function(pcc, n) {
  pcc.meta <- sum(n * pcc) / sum(n)
  return(pcc.meta)
}

pairwise.coexpression.matrices <- lapply(esets, function(eset) {
  gene.indices <- sapply(entrez.ids, function(entrez.id) {
    index <- which(fData(eset)$EntrezGene.ID == entrez.id)
      if(length(index) > 1) {
        stop("Found a different number than one matching Entrez ID")
      } else if(length(index) == 0) {
        return(NA)
        }
      return(index)
    })
  names(gene.indices) <- gene.names
  pairwise.correlation.matrix <- sapply(gene.indices, function(index1) {
    return(sapply(gene.indices, function(index2) 
      cor(exprs(eset)[index1,], exprs(eset)[index2,], method = 'pearson')
      ))
    })
  })


meta.coexpression.matrix <- sapply(1:length(gene.names), function(x) sapply(1:length(gene.names), function(y) {
  coexp.vals <- sapply(pairwise.coexpression.matrices, function(coexp.matrix) coexp.matrix[x,y])
  meta.coexp <- get.meta.correlation(coexp.vals, sapply(esets, ncol))
  }))

rownames(meta.coexpression.matrix) <- gene.names
colnames(meta.coexpression.matrix) <- gene.names

hclust.ord <- hclust(dist(meta.coexpression.matrix))$ord

meta.coexpression.matrix <- meta.coexpression.matrix[hclust.ord, rev(hclust.ord)]

meta.coexpression.matrix.m <- melt(meta.coexpression.matrix)

ggplot(meta.coexpression.matrix.m, aes(Var1, Var2)) + 
    geom_tile(aes(fill = value), colour = "black") + 
    scale_fill_gradient2(name="Correlation", low="#2166ac", mid="white", high="#b2182b", limits=c(-1,1)) +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.text.y = element_text(angle = 90), axis.title.x = element_blank(), axis.title.y = element_blank(), legend.position='none') + geom_text(label=as.numeric(sprintf("%.2f", meta.coexpression.matrix)), colour="black")
@
<<single_gene, cache=FALSE, include=FALSE>>=
set.seed(500)
knitr.text <- lapply(1:length(entrez.ids), function(current.index) knit_expand(file='brca.single.gene.template.Rnw'))

random.effects.pval <- c()
random.effects.estimate <- c()
random.effects.lower <- c()
random.effects.upper <- c()
rma.objs <- list()

hr.matrix <- matrix(nrow=length(gene.names), ncol=length(esets.rfs))
rownames(hr.matrix) <- gene.names
colnames(hr.matrix) <- names(esets.rfs)

knitr.out <- knit(text=unlist(knitr.text))
@

\section{Gene Set Enrichment Analysis}

<<GSEA_computation>>=
gsa.matrix <- sapply(entrez.ids, function(entrez.id) {
  # For each dataset: if it contains some patients with the genes, remove patients with NA values for these genes
  esets.with.gene <- lapply(esets, function(eset) {
    eset <- eset[complete.cases(exprs(eset)),]
    return(eset)
  })
  # Remove any dataset with fewer than 10000 features
  esets.with.gene <- esets.with.gene[sapply(esets.with.gene, function(eset) nrow(eset) > 10000)]
  
  # only keep esets with the gene
  esets.with.gene <- esets.with.gene[sapply(esets.with.gene, function(eset) entrez.id %in% fData(eset)$EntrezGene.ID )]
  
  intersecting.entrez.ids <- Reduce(intersect, sapply(esets.with.gene, function(eset) as.character(fData(eset)$EntrezGene.ID)))
  intersecting.entrez.ids <- as.numeric(intersecting.entrez.ids)
  
  correlation.matrix <- sapply(esets.with.gene, function(eset) {
      gene.of.interest.index <- which(fData(eset)$EntrezGene.ID == entrez.id)
      entrez.id.exprs.vals <- exprs(eset)[gene.of.interest.index,]
      eset <- eset[fData(eset)$EntrezGene.ID %in% intersecting.entrez.ids,]
      cor.values <- apply(exprs(eset), 1, function(gene.exp.vals) cor(gene.exp.vals, entrez.id.exprs.vals, method='pearson'))
      cor.values <- cor.values[match(as.numeric(as.character(fData(eset)$EntrezGene.ID)), intersecting.entrez.ids)]
      return(cor.values)
    })
  
  meta.correlation.vals <- apply(correlation.matrix, 1, function(gene.correlation.vals) get.meta.correlation.hunter.schmidt(pcc = gene.correlation.vals, n=sapply(esets.with.gene, ncol)))
  
  names(meta.correlation.vals) <- sub("geneid.", "", names(meta.correlation.vals))
  
  c5.bp.geneset <- piano::loadGSC("c5.bp.v5.1.entrez.gmt")
  
  gsa.out <- runGSA(meta.correlation.vals, gsc=c5.bp.geneset, ncpus = 4)
  
  gsa.up.vals <- gsa.out$pAdjDistinctDirUp
  
  rownames(gsa.up.vals) <- names(gsa.out$gsc)
  
  return(gsa.up.vals)
})

@

\section{Survival Analysis}

\subsection{Summary of Results}

<<summary_table, results='asis'>>=
summary.table <- data.frame(gene=gene.names, pval=sprintf("%.5f", random.effects.pval), hr.text=sprintf("%.2f [%.2f, %.2f]", random.effects.estimate, random.effects.lower, random.effects.upper))
colnames(summary.table) <- c("Gene Name", "P-value", "Hazard Ratio")
print(xtable(summary.table),include.rownames=FALSE)


@

<<summary_heatmap, fig.width=13, fig.height=5>>= 
.getHeatmap <- function(stat.matrix) {
    stat.matrix.m <- melt(stat.matrix)
    #if(cluster==TRUE) {
      ord <- hclust(dist(t(log(stat.matrix)), method="euclidean"))$order
    #}
    colnames(stat.matrix.m) <- c("Gene", "Dataset", "HR")
    stat.matrix.m$Gene <- factor(stat.matrix.m$Gene, levels=rev(rownames(stat.matrix)))
    stat.matrix.m$Dataset <- factor(stat.matrix.m$Dataset, levels=levels(stat.matrix.m$Dataset)[ord])
    
    p <- ggplot(stat.matrix.m, aes_string("Dataset", "Gene")) + 
      geom_tile(aes(fill = HR), colour = "white") + 
      scale_fill_gradient2(low="#67a9cf", mid="#f7f7f7", high="#ef8a62", trans="log", breaks=c(0.5,1,2), limits=exp(c(-1.14,1.14))) + 
      theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank())
    
      #geom_text(label=as.character(contingency.matrix), colour="white")
    return(p)
}

.getHeatmap(exp(hr.matrix))
@

<<summary_forestplot, fig.width=8, fig.height=10>>=
estimates <- sapply(rma.objs, coef)
variances <- sapply(rma.objs, vcov)

#forest(estimates, variances, atransf=exp, psize=1, efac=0, slab=names(rma.objs), xlab="Hazard Ratio",xlim=c(-2,2), at=log(c(0.25,0.5,1,2,4)))
forest(estimates, variances, atransf=exp, psize=1, efac=0, slab=names(rma.objs), xlab="Hazard Ratio",xlim=c(-2,3.5), at=log(c(0.25,0.5,1,2,4)), ilab = sprintf("%.2e", random.effects.pval), ilab.xpos = 1.5)
op <- par(cex=1, font=2)
text(-2, length(gene.names) + 1.5, "Gene", pos=4)
text(1.5, length(gene.names) + 1.5, "p-value")
text(3.5, length(gene.names) + 1.5, "Hazard Ratio [95% CI]", pos=2)
addpoly(estimates, variances, rows=length(rma.objs):1, atransf=exp, annotate=FALSE)
abline(h=0.5, lwd=1)
par(op)
@

\pagebreak

\Sexpr{knitr.out}

\pagebreak

\section{R SessionInfo}

<<r_session_info, include=TRUE, echo=TRUE, results='markup'>>=
devtools::session_info()
@

\end{document}